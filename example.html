<html>
    <body>
<div class="QuickAnswerContent_markdown__x0uyH"><div class="Markdown_content__QHlJX"><h2 id="for-loop-traditional-but-still-hip" data-chapter="for-loop-traditional-but-still-hip" class="H2_h2__vp9wi">For Loop — traditional but still hip</h2>
<p node="[object Object]" class="">Need to <span class="HeadingStrong_heading__swB4n">execute promises sequentially</span>? Don't fret! Either deploy the <code class="Code_inline__xEegJ __className_b01201">Array.reduce()</code> method or bring <span class="">async/await</span> into the equation contained within a loop. Here's <code class="Code_inline__xEegJ __className_b01201">reduce()</code> in its full glory:</p>
<pre><div class="Code_snippetContainer__RhtQu"><div class="Code_snippet__rEsBB language-javascript __className_b01201" style="display: block; overflow: hidden; padding: 0.5em; color: rgb(255, 255, 255); background: rgb(28, 27, 27);"><code class="language-javascript" style="white-space: pre;"><span style="word-break: break-word; white-space: pre-wrap;"><span style="color: rgb(136, 174, 206);">let</span><span> promiseFactory = [fn1, fn2, fn3]; </span><span style="color: rgb(153, 153, 153);">// These dudes return a Promise</span><span>
</span></span><span style="word-break: break-word; white-space: pre-wrap;"><span>promiseFactory.reduce(</span><span class="hljs-function">(</span><span class="hljs-function hljs-params">prevPromise, nextFn</span><span class="hljs-function">) =&gt;</span><span> prevPromise.then(nextFn), </span><span style="color: rgb(240, 141, 73);">Promise</span><span>.resolve()).then(</span><span class="hljs-function hljs-params">result</span><span class="hljs-function"> =&gt;</span><span> </span><span style="color: rgb(240, 141, 73);">console</span><span>.log(</span><span style="color: rgb(181, 189, 104);">`Executed in sequence. Feel like James Bond yet?`</span><span>));</span></span></code></div><button class="Code_snippetCopyButton__2k3dT __className_889da0" type="button" title="Copy"></button></div></pre>
<p node="[object Object]" class="">Got that? Perfect! Each promise cordially waits its turn and only gets initiated after the one before has wrapped up. Now, let's leap into the <span class="">exciting world of async/await</span>:</p>
<pre><div class="Code_snippetContainer__RhtQu"><div class="Code_snippet__rEsBB language-javascript __className_b01201" style="display: block; overflow: hidden; padding: 0.5em; color: rgb(255, 255, 255); background: rgb(28, 27, 27);"><code class="language-javascript" style="white-space: pre;"><span style="word-break: break-word; white-space: pre-wrap;"><span style="color: rgb(136, 174, 206);">async</span><span> </span><span class="hljs-function" style="color: rgb(136, 174, 206);">function</span><span class="hljs-function"> </span><span class="hljs-function" style="color: rgb(240, 141, 73);">keepInLine</span><span class="hljs-function">(</span><span class="hljs-function hljs-params">tasks</span><span class="hljs-function">) </span><span>{
</span></span><span style="word-break: break-word; white-space: pre-wrap;"><span>  </span><span style="color: rgb(136, 174, 206);">for</span><span> (</span><span style="color: rgb(136, 174, 206);">const</span><span> task </span><span style="color: rgb(136, 174, 206);">of</span><span> tasks) {
</span></span><span style="word-break: break-word; white-space: pre-wrap;"><span>    </span><span style="color: rgb(136, 174, 206);">await</span><span> task(); </span><span style="color: rgb(153, 153, 153);">// Politely making sure each task finishes its job before the next one comes into the picture.</span><span>
</span></span><span style="word-break: break-word; white-space: pre-wrap;">  }
</span><span style="word-break: break-word; white-space: pre-wrap;">}</span></code></div><button class="Code_snippetCopyButton__2k3dT __className_889da0" type="button" title="Copy"></button></div></pre>
<p node="[object Object]" class="">The use of <code class="Code_inline__xEegJ __className_b01201">await</code> within this loop guarantees a structured, orderly execution of tasks in a wonderfully <span class="">asynchronous</span> fashion.</p>
<h2 id="know-thy-promise" data-chapter="know-thy-promise" class="H2_h2__vp9wi">Know thy Promise</h2>
<h3 id="promises-born-ready" data-chapter="promises-born-ready" class="H3_h3__XNY1h">Promises — born ready</h3>
<p node="[object Object]" class="">Respect a <span class="">new Promise</span>! It doesn't dilly-dally. As soon as it steps into the world, it gets its executor function rolling. So, remember, by the moment you pass your promises to <code class="Code_inline__xEegJ __className_b01201">Promise.all</code>, the tasks are already in <span class="">full swing</span>.</p>
<h3 id="promiseallsettled-the-patient-friend" data-chapter="promiseallsettled-the-patient-friend" class="H3_h3__XNY1h"><code class="Code_inline__xEegJ __className_b01201">Promise.allSettled</code> — the patient friend</h3>
<p node="[object Object]" class="">Ever had one of those situations where you need to nail all results but don't want a single botched attempt to <span class="">abort</span> the entire mission? Say hello <code class="Code_inline__xEegJ __className_b01201">Promise.allSettled</code>. This smooth opera sits tight, waiting for all promises to <span class="">settle down</span> (either fulfilled or rejected).</p>
<h3 id="concurrent-vs-parallel-processing" data-chapter="concurrent-vs-parallel-processing" class="H3_h3__XNY1h">Concurrent vs. parallel processing</h3>
<p node="[object Object]" class="">Here's the tea: despite its massive talent, Node.js can't boast of actual parallelism due to being single-threaded. However, it makes a brilliant show of handling "concurrent" tasks seamlessly, all thanks to the dynamic <span class="">event loop</span> that cleverly utilizes <span class="">non-blocking I/O operations</span>.</p>
<h2 id="diving-deeper" data-chapter="diving-deeper" class="H2_h2__vp9wi">Diving deeper</h2>
<h3 id="sequential-processing-with-shared-resources" data-chapter="sequential-processing-with-shared-resources" class="H3_h3__XNY1h">Sequential processing with shared resources</h3>
<p node="[object Object]" class="">In those instances when you need to <span class="">share resources</span> across your operations, a good old <code class="Code_inline__xEegJ __className_b01201">for</code> loop synergizing with <span class="">async/await</span> could be your best companion:</p>
<pre><div class="Code_snippetContainer__RhtQu"><div class="Code_snippet__rEsBB language-javascript __className_b01201" style="display: block; overflow: hidden; padding: 0.5em; color: rgb(255, 255, 255); background: rgb(28, 27, 27);"><code class="language-javascript" style="white-space: pre;"><span style="word-break: break-word; white-space: pre-wrap;"><span style="color: rgb(136, 174, 206);">let</span><span> sharedResources = {};
</span></span><span style="word-break: break-word; white-space: pre-wrap;">
</span><span style="word-break: break-word; white-space: pre-wrap;"><span></span><span style="color: rgb(136, 174, 206);">async</span><span> </span><span class="hljs-function" style="color: rgb(136, 174, 206);">function</span><span class="hljs-function"> </span><span class="hljs-function" style="color: rgb(240, 141, 73);">danceInSequence</span><span class="hljs-function">(</span><span class="hljs-function hljs-params">tasks, resources</span><span class="hljs-function">) </span><span>{
</span></span><span style="word-break: break-word; white-space: pre-wrap;"><span>  </span><span style="color: rgb(136, 174, 206);">for</span><span> (</span><span style="color: rgb(136, 174, 206);">const</span><span> task </span><span style="color: rgb(136, 174, 206);">of</span><span> tasks) {
</span></span><span style="word-break: break-word; white-space: pre-wrap;"><span>    </span><span style="color: rgb(240, 141, 73);">Object</span><span>.assign(resources, </span><span style="color: rgb(136, 174, 206);">await</span><span> task(resources)); </span><span style="color: rgb(153, 153, 153);">// Sharing is caring!</span><span>
</span></span><span style="word-break: break-word; white-space: pre-wrap;">  }
</span><span style="word-break: break-word; white-space: pre-wrap;">}</span></code></div><button class="Code_snippetCopyButton__2k3dT __className_889da0" type="button" title="Copy"></button></div></pre>
<p node="[object Object]" class="">Using this code, each task gets a share of the <span class="">resources</span> and is even allowed to <span class="">alter</span> it before the next task steps in.</p>
<h3 id="the-art-of-promise-chaining" data-chapter="the-art-of-promise-chaining" class="H3_h3__XNY1h">The art of promise chaining</h3>
<p node="[object Object]" class="">Are you chaining with <code class="Code_inline__xEegJ __className_b01201">.then</code>? Cool. Now remember to return a <span class="">new Promise</span>:</p>
<pre><div class="Code_snippetContainer__RhtQu"><div class="Code_snippet__rEsBB language-javascript __className_b01201" style="display: block; overflow: hidden; padding: 0.5em; color: rgb(255, 255, 255); background: rgb(28, 27, 27);"><code class="language-javascript" style="white-space: pre;"><span style="word-break: break-word; white-space: pre-wrap;"><span>promise.then(</span><span class="hljs-function hljs-params">result</span><span class="hljs-function"> =&gt;</span><span> {
</span></span><span style="word-break: break-word; white-space: pre-wrap;"><span>  </span><span style="color: rgb(136, 174, 206);">return</span><span> </span><span style="color: rgb(136, 174, 206);">new</span><span> </span><span style="color: rgb(240, 141, 73);">Promise</span><span>(</span><span class="hljs-function">(</span><span class="hljs-function hljs-params">resolve, reject</span><span class="hljs-function">) =&gt;</span><span> {
</span></span><span style="word-break: break-word; white-space: pre-wrap;"><span>    </span><span style="color: rgb(153, 153, 153);">// Some magical async operation happens here!</span><span>
</span></span><span style="word-break: break-word; white-space: pre-wrap;">  });
</span><span style="word-break: break-word; white-space: pre-wrap;">});</span></code></div><button class="Code_snippetCopyButton__2k3dT __className_889da0" type="button" title="Copy"></button></div></pre>
<p node="[object Object]" class="">Forgetting to return a promise could cause a commotion, disturbing the promise <span class="">chain</span> and resulting in a rather unruly error or unexpected behavior.</p>
<h2 id="extra-finesse" data-chapter="extra-finesse" class="H2_h2__vp9wi">Extra finesse</h2>
<h3 id="using-recursion-for-sequential-execution" data-chapter="using-recursion-for-sequential-execution" class="H3_h3__XNY1h">Using recursion for sequential execution</h3>
<p node="[object Object]" class="">Got a dynamic list of promises? Recursion can be a <span class="">compact solution</span> to make them march in sequence:</p>
<pre><div class="Code_snippetContainer__RhtQu"><div class="Code_snippet__rEsBB language-javascript __className_b01201" style="display: block; overflow: hidden; padding: 0.5em; color: rgb(255, 255, 255); background: rgb(28, 27, 27);"><code class="language-javascript" style="white-space: pre;"><span style="word-break: break-word; white-space: pre-wrap;"><span style="color: rgb(136, 174, 206);">async</span><span> </span><span class="hljs-function" style="color: rgb(136, 174, 206);">function</span><span class="hljs-function"> </span><span class="hljs-function" style="color: rgb(240, 141, 73);">marchOneByOne</span><span class="hljs-function">(</span><span class="hljs-function hljs-params">index, tasks</span><span class="hljs-function">) </span><span>{
</span></span><span style="word-break: break-word; white-space: pre-wrap;"><span>  </span><span style="color: rgb(136, 174, 206);">if</span><span> (index &gt;= tasks.length) {
</span></span><span style="word-break: break-word; white-space: pre-wrap;"><span>    </span><span style="color: rgb(136, 174, 206);">return</span><span> </span><span style="color: rgb(240, 141, 73);">Promise</span><span>.resolve(); </span><span style="color: rgb(153, 153, 153);">// Hey, where did everyone go?</span><span>
</span></span><span style="word-break: break-word; white-space: pre-wrap;">  }
</span><span style="word-break: break-word; white-space: pre-wrap;"><span>  </span><span style="color: rgb(136, 174, 206);">return</span><span> tasks[index]().then(</span><span class="hljs-function">() =&gt;</span><span> marchOneByOne(index + </span><span style="color: rgb(240, 141, 73);">1</span><span>, tasks)); </span><span style="color: rgb(153, 153, 153);">// Cool. Now, let's get the next one going.</span><span>
</span></span><span style="word-break: break-word; white-space: pre-wrap;">}
</span><span style="word-break: break-word; white-space: pre-wrap;">
</span><span style="word-break: break-word; white-space: pre-wrap;"><span></span><span style="color: rgb(153, 153, 153);">// Let's begin the march!</span><span>
</span></span><span style="word-break: break-word; white-space: pre-wrap;"><span>marchOneByOne(</span><span style="color: rgb(240, 141, 73);">0</span><span>, promiseFactories)
</span></span><span style="word-break: break-word; white-space: pre-wrap;"><span>  .then(</span><span class="hljs-function">() =&gt;</span><span> </span><span style="color: rgb(240, 141, 73);">console</span><span>.log(</span><span style="color: rgb(181, 189, 104);">"Finished marching. Time for ice cream!"</span><span>));</span></span></code></div><button class="Code_snippetCopyButton__2k3dT __className_889da0" type="button" title="Copy"></button></div></pre>
<h3 id="simulating-async-operations" data-chapter="simulating-async-operations" class="H3_h3__XNY1h">Simulating async operations</h3>
<p node="[object Object]" class=""><code class="Code_inline__xEegJ __className_b01201">setTimeout</code> can act as a wonderful <span class="">asynchronous operation</span> stand-in for simulation purposes:</p>
<pre><div class="Code_snippetContainer__RhtQu"><div class="Code_snippet__rEsBB language-javascript __className_b01201" style="display: block; overflow: hidden; padding: 0.5em; color: rgb(255, 255, 255); background: rgb(28, 27, 27);"><code class="language-javascript" style="white-space: pre;"><span style="word-break: break-word; white-space: pre-wrap;"><span class="hljs-function" style="color: rgb(136, 174, 206);">function</span><span class="hljs-function"> </span><span class="hljs-function" style="color: rgb(240, 141, 73);">pretendPromise</span><span class="hljs-function">(</span><span class="hljs-function hljs-params">result, delay</span><span class="hljs-function">) </span><span>{
</span></span><span style="word-break: break-word; white-space: pre-wrap;"><span>  </span><span style="color: rgb(136, 174, 206);">return</span><span> </span><span style="color: rgb(136, 174, 206);">new</span><span> </span><span style="color: rgb(240, 141, 73);">Promise</span><span>(</span><span class="hljs-function hljs-params">resolve</span><span class="hljs-function"> =&gt;</span><span> </span><span style="color: rgb(240, 141, 73);">setTimeout</span><span>(</span><span class="hljs-function">() =&gt;</span><span> resolve(result), delay))
</span></span><span style="word-break: break-word; white-space: pre-wrap;"><span>  .then(</span><span class="hljs-function">() =&gt;</span><span> </span><span style="color: rgb(240, 141, 73);">console</span><span>.log(</span><span style="color: rgb(181, 189, 104);">"This promise got fulfilled faster than a catfish on a hot tin roof!"</span><span>));
</span></span><span style="word-break: break-word; white-space: pre-wrap;">}</span></code></div><button class="Code_snippetCopyButton__2k3dT __className_889da0" type="button" title="Copy"></button></div></pre>
<p node="[object Object]" class="">Now, you can test your <span class="">promise logic</span> without reliance on actual I/O tasks. How cool is that?</p>
<h3 id="a-stitch-in-time-error-handling" data-chapter="a-stitch-in-time-error-handling" class="H3_h3__XNY1h">A stitch in time: error handling</h3>
<p node="[object Object]" class="">It's crucial to incorporate <span class="">error handling</span> for your noble promise chains to prevent them from catching unhandled rejections:</p>
<pre><div class="Code_snippetContainer__RhtQu"><div class="Code_snippet__rEsBB language-javascript __className_b01201" style="display: block; overflow: hidden; padding: 0.5em; color: rgb(255, 255, 255); background: rgb(28, 27, 27);"><code class="language-javascript" style="white-space: pre;"><span style="word-break: break-word; white-space: pre-wrap;"><span style="color: rgb(240, 141, 73);">Promise</span><span>.all(promises)
</span></span><span style="word-break: break-word; white-space: pre-wrap;"><span>  .then(</span><span class="hljs-function hljs-params">results</span><span class="hljs-function"> =&gt;</span><span> </span><span style="color: rgb(240, 141, 73);">console</span><span>.log(results))
</span></span><span style="word-break: break-word; white-space: pre-wrap;"><span>  .catch(</span><span class="hljs-function hljs-params">error</span><span class="hljs-function"> =&gt;</span><span> </span><span style="color: rgb(240, 141, 73);">console</span><span>.error(</span><span style="color: rgb(181, 189, 104);">"Houston, we have a problem!"</span><span>, error));</span></span></code></div><button class="Code_snippetCopyButton__2k3dT __className_889da0" type="button" title="Copy"></button></div></pre>
<p node="[object Object]" class="">This intelligent measure can ensure your concurrent processing remains <span class="">robust</span>, even when the going gets tough.</p></div></div>
</body>
</html>
